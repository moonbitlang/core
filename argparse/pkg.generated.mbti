// Generated using `moon info`, DON'T EDIT IT
package "moonbitlang/core/argparse"

import {
  "moonbitlang/core/debug",
}

// Values

// Errors
pub suberror ArgError {
  Message(String)
}
pub impl Show for ArgError

// Types and methods
pub struct ArgGroup {
  // private fields

  fn new(StringView, required? : Bool, multiple? : Bool, args? : ArrayView[String], requires? : ArrayView[String], conflicts_with? : ArrayView[String]) -> ArgGroup
}
pub fn ArgGroup::new(StringView, required? : Bool, multiple? : Bool, args? : ArrayView[String], requires? : ArrayView[String], conflicts_with? : ArrayView[String]) -> Self

pub struct Command {
  // private fields

  fn new(StringView, flags? : ArrayView[FlagArg], options? : ArrayView[OptionArg], positionals? : ArrayView[PositionalArg], subcommands? : ArrayView[Command], about? : StringView, version? : StringView, disable_help_flag? : Bool, disable_version_flag? : Bool, disable_help_subcommand? : Bool, arg_required_else_help? : Bool, subcommand_required? : Bool, hidden? : Bool, groups? : ArrayView[ArgGroup]) -> Command
}
pub fn Command::new(StringView, flags? : ArrayView[FlagArg], options? : ArrayView[OptionArg], positionals? : ArrayView[PositionalArg], subcommands? : ArrayView[Self], about? : StringView, version? : StringView, disable_help_flag? : Bool, disable_version_flag? : Bool, disable_help_subcommand? : Bool, arg_required_else_help? : Bool, subcommand_required? : Bool, hidden? : Bool, groups? : ArrayView[ArgGroup]) -> Self
#as_free_fn
pub fn Command::parse(Self, argv? : ArrayView[String], env? : Map[String, String]) -> Matches raise ArgError
pub fn Command::render_help(Self) -> String

pub(all) enum FlagAction {
  SetTrue
  SetFalse
  Count
  Help
  Version
}
pub impl Eq for FlagAction
pub impl Show for FlagAction

pub struct FlagArg {
  // private fields

  fn new(StringView, short? : Char, long? : StringView, about? : StringView, action? : FlagAction, env? : StringView, requires? : ArrayView[String], conflicts_with? : ArrayView[String], required? : Bool, global? : Bool, negatable? : Bool, hidden? : Bool) -> FlagArg
}
pub fn FlagArg::new(StringView, short? : Char, long? : StringView, about? : StringView, action? : FlagAction, env? : StringView, requires? : ArrayView[String], conflicts_with? : ArrayView[String], required? : Bool, global? : Bool, negatable? : Bool, hidden? : Bool) -> Self

pub struct Matches {
  flags : Map[String, Bool]
  values : Map[String, Array[String]]
  flag_counts : Map[String, Int]
  sources : Map[String, ValueSource]
  subcommand : (String, Matches)?
  // private fields
}
pub impl @debug.Debug for Matches

pub(all) enum OptionAction {
  Set
  Append
}
pub impl Eq for OptionAction
pub impl Show for OptionAction

pub struct OptionArg {
  // private fields

  fn new(StringView, short? : Char, long? : StringView, about? : StringView, action? : OptionAction, env? : StringView, default_values? : ArrayView[String], allow_hyphen_values? : Bool, requires? : ArrayView[String], conflicts_with? : ArrayView[String], required? : Bool, global? : Bool, hidden? : Bool) -> OptionArg
}
pub fn OptionArg::new(StringView, short? : Char, long? : StringView, about? : StringView, action? : OptionAction, env? : StringView, default_values? : ArrayView[String], allow_hyphen_values? : Bool, requires? : ArrayView[String], conflicts_with? : ArrayView[String], required? : Bool, global? : Bool, hidden? : Bool) -> Self

pub struct PositionalArg {
  // private fields

  fn new(StringView, about? : StringView, env? : StringView, default_values? : ArrayView[String], num_args? : ValueRange, allow_hyphen_values? : Bool, last? : Bool, requires? : ArrayView[String], conflicts_with? : ArrayView[String], required? : Bool, global? : Bool, hidden? : Bool) -> PositionalArg
}
pub fn PositionalArg::new(StringView, about? : StringView, env? : StringView, default_values? : ArrayView[String], num_args? : ValueRange, allow_hyphen_values? : Bool, last? : Bool, requires? : ArrayView[String], conflicts_with? : ArrayView[String], required? : Bool, global? : Bool, hidden? : Bool) -> Self

pub struct ValueRange {
  // private fields

  fn new(lower? : Int, upper? : Int) -> ValueRange
}
pub fn ValueRange::new(lower? : Int, upper? : Int) -> Self
pub fn ValueRange::single() -> Self
pub impl Eq for ValueRange
pub impl Show for ValueRange

pub enum ValueSource {
  Argv
  Env
  Default
}
pub impl Eq for ValueSource
pub impl Show for ValueSource
pub impl @debug.Debug for ValueSource

// Type aliases

// Traits

