// Generated using `moon info`, DON'T EDIT IT
package "moonbitlang/core/result"

import(
  "moonbitlang/core/quickcheck"
  "moonbitlang/core/quickcheck/splitmix"
)

// Values
#deprecated
fn[T, E] err(E) -> Result[T, E]

#deprecated
fn[T, E] ok(T) -> Result[T, E]

// Errors

// Types and methods
fn[T : @quickcheck.Arbitrary, E : @quickcheck.Arbitrary] Result::arbitrary(Int, @splitmix.RandomState) -> Self[T, E] // from trait `@quickcheck.Arbitrary`
fn[T, E, U] Result::bind(Self[T, E], (T) -> Self[U, E]) -> Self[U, E]
fn[T : Compare, E : Compare] Result::compare(Self[T, E], Self[T, E]) -> Int // from trait `Compare`
fn[T, E] Result::flatten(Self[Self[T, E], E]) -> Self[T, E]
#deprecated
fn[T, E, V] Result::fold(Self[T, E], (T) -> V, (E) -> V) -> V
#deprecated
fn[T, E] Result::is_err(Self[T, E]) -> Bool
#deprecated
fn[T, E] Result::is_ok(Self[T, E]) -> Bool
fn[T, E, U] Result::map(Self[T, E], (T) -> U) -> Self[U, E]
fn[T, E, F] Result::map_err(Self[T, E], (E) -> F) -> Self[T, F]
fn[T : Compare, E : Compare] Result::op_ge(Self[T, E], Self[T, E]) -> Bool // from trait `Compare`
fn[T : Compare, E : Compare] Result::op_gt(Self[T, E], Self[T, E]) -> Bool // from trait `Compare`
fn[T : Compare, E : Compare] Result::op_le(Self[T, E], Self[T, E]) -> Bool // from trait `Compare`
fn[T : Compare, E : Compare] Result::op_lt(Self[T, E], Self[T, E]) -> Bool // from trait `Compare`
fn[T, E] Result::or(Self[T, E], T) -> T
fn[T, E] Result::or_else(Self[T, E], () -> T) -> T
fn[T, E] Result::to_option(Self[T, E]) -> T?
fn[T, E] Result::unwrap(Self[T, E]) -> T
fn[T, E] Result::unwrap_err(Self[T, E]) -> E
fn[T, E] Result::unwrap_or(Self[T, E], T) -> T
fn[T : Default, E] Result::unwrap_or_default(Self[T, E]) -> T
fn[T, E] Result::unwrap_or_else(Self[T, E], () -> T raise?) -> T raise?
fn[T, E : Error] Result::unwrap_or_error(Self[T, E]) -> T raise E
impl[T : Compare, E : Compare] Compare for Result[T, E]
impl[T : @quickcheck.Arbitrary, E : @quickcheck.Arbitrary] @quickcheck.Arbitrary for Result[T, E]

// Type aliases

// Traits

