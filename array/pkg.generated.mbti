// Generated using `moon info`, DON'T EDIT IT
package "moonbitlang/core/array"

import(
  "moonbitlang/core/quickcheck"
  "moonbitlang/core/quickcheck/splitmix"
  "moonbitlang/core/string"
)

// Values
fn[A, B, C] zip_with(Array[A], Array[B], (A, B) -> C raise?) -> Array[C] raise?

// Errors

// Types and methods
fn[T] FixedArray::add(Self[T], Self[T]) -> Self[T] // from trait `Add`
fn[T] FixedArray::all(Self[T], (T) -> Bool raise?) -> Bool raise?
fn[T] FixedArray::any(Self[T], (T) -> Bool raise?) -> Bool raise?
fn[X : @quickcheck.Arbitrary] FixedArray::arbitrary(Int, @splitmix.RandomState) -> Self[X] // from trait `@quickcheck.Arbitrary`
fn FixedArray::blit_from_bytesview(Self[Byte], Int, BytesView) -> Unit
fn[T : Compare] FixedArray::compare(Self[T], Self[T]) -> Int // from trait `Compare`
fn[T : Eq] FixedArray::contains(Self[T], T) -> Bool
fn[T] FixedArray::copy(Self[T]) -> Self[T]
fn[T] FixedArray::each(Self[T], (T) -> Unit raise?) -> Unit raise?
fn[T] FixedArray::eachi(Self[T], (Int, T) -> Unit raise?) -> Unit raise?
fn[T : Eq] FixedArray::ends_with(Self[T], Self[T]) -> Bool
fn[T : Eq] FixedArray::equal(Self[T], Self[T]) -> Bool // from trait `Eq`
fn[A, B] FixedArray::fold(Self[A], init~ : B, (B, A) -> B raise?) -> B raise?
fn[A, B] FixedArray::foldi(Self[A], init~ : B, (Int, B, A) -> B raise?) -> B raise?
fn[T] FixedArray::from_array(ArrayView[T]) -> Self[T]
fn[T] FixedArray::from_iter(Iter[T]) -> Self[T]
fn[T] FixedArray::from_iterator(Iterator[T]) -> Self[T]
fn[T : Hash] FixedArray::hash(Self[T]) -> Int // from trait `Hash`
fn[T : Hash] FixedArray::hash_combine(Self[T], Hasher) -> Unit // from trait `Hash`
fn[T : Compare] FixedArray::is_sorted(Self[T]) -> Bool
fn[X] FixedArray::iterator(Self[X]) -> Iterator[X]
fn FixedArray::join(Self[String], StringView) -> String
fn[A] FixedArray::last(Self[A]) -> A?
fn[T] FixedArray::makei(Int, (Int) -> T raise?) -> Self[T] raise?
fn[T, U] FixedArray::map(Self[T], (T) -> U raise?) -> Self[U] raise?
fn[T, U] FixedArray::mapi(Self[T], (Int, T) -> U raise?) -> Self[U] raise?
#deprecated
fn[T] FixedArray::op_add(Self[T], Self[T]) -> Self[T] // from trait `Add`
#deprecated
fn[T : Eq] FixedArray::op_equal(Self[T], Self[T]) -> Bool // from trait `Eq`
fn[T] FixedArray::rev(Self[T]) -> Self[T]
fn[T] FixedArray::rev_each(Self[T], (T) -> Unit raise?) -> Unit raise?
fn[T] FixedArray::rev_eachi(Self[T], (Int, T) -> Unit raise?) -> Unit raise?
fn[A, B] FixedArray::rev_fold(Self[A], init~ : B, (B, A) -> B raise?) -> B raise?
fn[A, B] FixedArray::rev_foldi(Self[A], init~ : B, (Int, B, A) -> B raise?) -> B raise?
fn[T] FixedArray::rev_inplace(Self[T]) -> Unit
fn[T : Eq] FixedArray::search(Self[T], T) -> Int?
fn[T : Compare] FixedArray::sort(Self[T]) -> Unit
fn[T] FixedArray::sort_by(Self[T], (T, T) -> Int) -> Unit
fn[T, K : Compare] FixedArray::sort_by_key(Self[T], (T) -> K) -> Unit
fn[T : Compare] FixedArray::stable_sort(Self[T]) -> Unit
fn[T : Eq] FixedArray::starts_with(Self[T], Self[T]) -> Bool
fn[T] FixedArray::swap(Self[T], Int, Int) -> Unit
fn FixedArray::unsafe_extract_bit(Self[Byte], Int, Int) -> UInt
fn FixedArray::unsafe_extract_byte(Self[Byte], Int, Int) -> UInt
fn FixedArray::unsafe_extract_bytesview(Self[Byte], Int, Int) -> ArrayView[Byte]
fn FixedArray::unsafe_extract_uint64_be(Self[Byte], Int, Int) -> UInt64
fn FixedArray::unsafe_extract_uint64_le(Self[Byte], Int, Int) -> UInt64
fn FixedArray::unsafe_extract_uint_be(Self[Byte], Int, Int) -> UInt
fn FixedArray::unsafe_extract_uint_le(Self[Byte], Int, Int) -> UInt
impl[T] Add for FixedArray[T]
impl[T : Compare] Compare for FixedArray[T]
impl[T : Eq] Eq for FixedArray[T]
impl[T : Hash] Hash for FixedArray[T]
impl[X : @quickcheck.Arbitrary] @quickcheck.Arbitrary for FixedArray[X]

fn[T] ReadOnlyArray::all(Self[T], (T) -> Bool raise?) -> Bool raise?
fn[T] ReadOnlyArray::any(Self[T], (T) -> Bool raise?) -> Bool raise?
#alias("_[_]")
fn[T] ReadOnlyArray::at(Self[T], Int) -> T
fn[T : Compare] ReadOnlyArray::binary_search(Self[T], T) -> Result[Int, Int]
fn[T] ReadOnlyArray::binary_search_by(Self[T], (T) -> Int raise?) -> Result[Int, Int] raise?
fn[T : Eq] ReadOnlyArray::contains(Self[T], T) -> Bool
fn[T] ReadOnlyArray::default() -> Self[T] // from trait `Default`
fn[T] ReadOnlyArray::each(Self[T], (T) -> Unit raise?) -> Unit raise?
fn[T] ReadOnlyArray::eachi(Self[T], (Int, T) -> Unit raise?) -> Unit raise?
fn[T : Eq] ReadOnlyArray::ends_with(Self[T], Self[T]) -> Bool
fn[A, B] ReadOnlyArray::fold(Self[A], init~ : B, (B, A) -> B raise?) -> B raise?
fn[A, B] ReadOnlyArray::foldi(Self[A], init~ : B, (Int, B, A) -> B raise?) -> B raise?
fn[T] ReadOnlyArray::from_array(ArrayView[T]) -> Self[T]
fn[T] ReadOnlyArray::from_iter(Iter[T]) -> Self[T]
fn[T] ReadOnlyArray::from_iterator(Iterator[T]) -> Self[T]
fn[T] ReadOnlyArray::get(Self[T], Int) -> T?
fn[T] ReadOnlyArray::is_empty(Self[T]) -> Bool
fn[T] ReadOnlyArray::iter(Self[T]) -> Iter[T]
fn[T] ReadOnlyArray::iter2(Self[T]) -> Iter2[Int, T]
fn[T] ReadOnlyArray::iterator(Self[T]) -> Iterator[T]
fn ReadOnlyArray::join(Self[String], StringView) -> String
fn[T] ReadOnlyArray::last(Self[T]) -> T?
fn[T] ReadOnlyArray::length(Self[T]) -> Int
fn[T] ReadOnlyArray::makei(Int, (Int) -> T raise?) -> Self[T] raise?
fn[T, U] ReadOnlyArray::map(Self[T], (T) -> U raise?) -> Self[U] raise?
fn[T, U] ReadOnlyArray::mapi(Self[T], (Int, T) -> U raise?) -> Self[U] raise?
fn[T : Show] ReadOnlyArray::output(Self[T], &Logger) -> Unit // from trait `Show`
fn[T] ReadOnlyArray::rev(Self[T]) -> Self[T]
fn[T] ReadOnlyArray::rev_each(Self[T], (T) -> Unit raise?) -> Unit raise?
fn[T] ReadOnlyArray::rev_eachi(Self[T], (Int, T) -> Unit raise?) -> Unit raise?
fn[A, B] ReadOnlyArray::rev_fold(Self[A], init~ : B, (B, A) -> B raise?) -> B raise?
fn[A, B] ReadOnlyArray::rev_foldi(Self[A], init~ : B, (Int, B, A) -> B raise?) -> B raise?
fn[T : Eq] ReadOnlyArray::search(Self[T], T) -> Int?
fn[T : Eq] ReadOnlyArray::starts_with(Self[T], Self[T]) -> Bool
#alias("_[_:_]")
fn[T] ReadOnlyArray::sub(Self[T], start? : Int, end? : Int) -> ArrayView[T]
fn[T : ToJson] ReadOnlyArray::to_json(Self[T]) -> Json // from trait `ToJson`
fn[T : Show] ReadOnlyArray::to_string(Self[T]) -> String // from trait `Show`
impl[T] Default for ReadOnlyArray[T]
impl[T : Show] Show for ReadOnlyArray[T]
impl[T : ToJson] ToJson for ReadOnlyArray[T]

fn[X : @quickcheck.Arbitrary] Array::arbitrary(Int, @splitmix.RandomState) -> Self[X] // from trait `@quickcheck.Arbitrary`
fn[T] Array::copy(Self[T]) -> Self[T]
fn[A, B] Array::filter_map(Self[A], (A) -> B? raise?) -> Self[B] raise?
fn[T] Array::from_iter(Iter[T]) -> Self[T]
fn[T] Array::from_iterator(Iterator[T]) -> Self[T]
fn[X] Array::iterator(Self[X]) -> Iterator[X]
fn[X] Array::iterator2(Self[X]) -> Iterator[(Int, X)]
fn[A : @string.ToStringView] Array::join(Self[A], StringView) -> String
fn[A] Array::last(Self[A]) -> A?
fn[T] Array::push_iter(Self[T], Iter[T]) -> Unit
fn[X] Array::rev_iterator(Self[X]) -> Iterator[X]
fn[T] Array::shuffle(Self[T], rand~ : (Int) -> Int) -> Self[T]
fn[T] Array::shuffle_in_place(Self[T], rand~ : (Int) -> Int) -> Unit
fn[T : Compare] Array::sort(Self[T]) -> Unit
fn[T] Array::sort_by(Self[T], (T, T) -> Int) -> Unit
fn[T, K : Compare] Array::sort_by_key(Self[T], (T) -> K) -> Unit
fn Array::unsafe_extract_bit(Self[Byte], Int, Int) -> UInt
fn Array::unsafe_extract_byte(Self[Byte], Int, Int) -> UInt
fn Array::unsafe_extract_bytesview(Self[Byte], Int, Int) -> ArrayView[Byte]
fn Array::unsafe_extract_uint64_be(Self[Byte], Int, Int) -> UInt64
fn Array::unsafe_extract_uint64_le(Self[Byte], Int, Int) -> UInt64
fn Array::unsafe_extract_uint_be(Self[Byte], Int, Int) -> UInt
fn Array::unsafe_extract_uint_le(Self[Byte], Int, Int) -> UInt
fn[T1, T2] Array::unzip(Self[(T1, T2)]) -> (Self[T1], Self[T2])
fn[A, B] Array::zip(Self[A], Self[B]) -> Self[(A, B)]
fn[A, B] Array::zip_to_iter2(Self[A], Self[B]) -> Iter2[A, B]
impl[X : @quickcheck.Arbitrary] @quickcheck.Arbitrary for Array[X]

fn[T] ArrayView::all(Self[T], (T) -> Bool raise?) -> Bool raise?
fn[T] ArrayView::any(Self[T], (T) -> Bool raise?) -> Bool raise?
fn[A : @quickcheck.Arbitrary] ArrayView::arbitrary(Int, @splitmix.RandomState) -> Self[A] // from trait `@quickcheck.Arbitrary`
fn[T : Compare] ArrayView::compare(Self[T], Self[T]) -> Int // from trait `Compare`
fn[T : Eq] ArrayView::contains(Self[T], T) -> Bool
fn[T] ArrayView::each(Self[T], (T) -> Unit raise?) -> Unit raise?
fn[T] ArrayView::eachi(Self[T], (Int, T) -> Unit raise?) -> Unit raise?
fn[T : Eq] ArrayView::equal(Self[T], Self[T]) -> Bool // from trait `Eq`
fn[T] ArrayView::filter(Self[T], (T) -> Bool raise?) -> Array[T] raise?
fn[A, B] ArrayView::fold(Self[A], init~ : B, (B, A) -> B raise?) -> B raise?
fn[A, B] ArrayView::foldi(Self[A], init~ : B, (Int, B, A) -> B raise?) -> B raise?
fn[A : Hash] ArrayView::hash(Self[A]) -> Int // from trait `Hash`
fn[A : Hash] ArrayView::hash_combine(Self[A], Hasher) -> Unit // from trait `Hash`
fn[A] ArrayView::iter(Self[A]) -> Iter[A]
fn[A] ArrayView::iter2(Self[A]) -> Iter2[Int, A]
fn[X] ArrayView::iterator(Self[X]) -> Iterator[X]
fn[X] ArrayView::iterator2(Self[X]) -> Iterator[(Int, X)]
fn[A : @string.ToStringView] ArrayView::join(Self[A], StringView) -> String
fn[T, U] ArrayView::map(Self[T], (T) -> U raise?) -> Array[U] raise?
fn[T, U] ArrayView::mapi(Self[T], (Int, T) -> U raise?) -> Array[U] raise?
#deprecated
fn[T : Eq] ArrayView::op_equal(Self[T], Self[T]) -> Bool // from trait `Eq`
fn[X : Show] ArrayView::output(Self[X], &Logger) -> Unit // from trait `Show`
fn[A, B] ArrayView::rev_fold(Self[A], init~ : B, (B, A) -> B raise?) -> B raise?
fn[A, B] ArrayView::rev_foldi(Self[A], init~ : B, (Int, B, A) -> B raise?) -> B raise?
fn[X] ArrayView::rev_iterator(Self[X]) -> Iterator[X]
fn[T] ArrayView::start_offset(Self[T]) -> Int
fn[T] ArrayView::to_array(Self[T]) -> Array[T]
fn[X : Show] ArrayView::to_string(Self[X]) -> String // from trait `Show`
fn ArrayView::unsafe_extract_bit(Self[Byte], Int, Int) -> UInt
fn ArrayView::unsafe_extract_byte(Self[Byte], Int, Int) -> UInt
fn ArrayView::unsafe_extract_bytesview(Self[Byte], Int, Int) -> Self[Byte]
fn ArrayView::unsafe_extract_uint64_be(Self[Byte], Int, Int) -> UInt64
fn ArrayView::unsafe_extract_uint64_le(Self[Byte], Int, Int) -> UInt64
fn ArrayView::unsafe_extract_uint_be(Self[Byte], Int, Int) -> UInt
fn ArrayView::unsafe_extract_uint_le(Self[Byte], Int, Int) -> UInt
impl[T : Compare] Compare for ArrayView[T]
impl[T : Eq] Eq for ArrayView[T]
impl[A : Hash] Hash for ArrayView[A]
impl[X : Show] Show for ArrayView[X]
impl[A : @quickcheck.Arbitrary] @quickcheck.Arbitrary for ArrayView[A]

// Type aliases
pub typealias ArrayView as View

// Traits

