package moonbitlang/core/deque

// Values

// Types and methods
type Deque
impl Deque {
  back[T](Self[T]) -> T?
  capacity[T](Self[T]) -> Int
  clear[T](Self[T]) -> Unit
  contains[T : Eq](Self[T], T) -> Bool
  each[T](Self[T], (T) -> Unit) -> Unit
  each_rev[T](Self[T], (T) -> Unit) -> Unit
  eachi[T](Self[T], (Int, T) -> Unit) -> Unit
  eachi_rev[T](Self[T], (Int, T) -> Unit) -> Unit
  from_array[T](Array[T]) -> Self[T]
  front[T](Self[T]) -> T?
  is_empty[T](Self[T]) -> Bool
  iter[T](Self[T]) -> Iter[T]
  length[T](Self[T]) -> Int
  map[T, U](Self[T], (T) -> U) -> Self[U]
  mapi[T, U](Self[T], (Int, T) -> U) -> Self[U]
  new[T](~capacity : Int = ..) -> Self[T]
  of[T](FixedArray[T]) -> Self[T]
  op_equal[T : Eq](Self[T], Self[T]) -> Bool
  op_get[T](Self[T], Int) -> T
  op_set[T](Self[T], Int, T) -> Unit
  pop_back[T](Self[T]) -> T?
  pop_back_exn[T](Self[T]) -> Unit
  pop_front[T](Self[T]) -> T?
  pop_front_exn[T](Self[T]) -> Unit
  push_back[T](Self[T], T) -> Unit
  push_front[T](Self[T], T) -> Unit
  reserve_capacity[T](Self[T], Int) -> Unit
  search[T : Eq](Self[T], T) -> Int?
  shrink_to_fit[T](Self[T]) -> Unit
  to_string[T : Show](Self[T]) -> String
}

// Traits

// Extension Methods

